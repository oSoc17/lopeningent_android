/*
 * Copyright (c) 2017 Hendrik Depauw
 * Copyright (c) 2017 Lorenz van Herwaarden
 * Copyright (c) 2017 Nick Aelterman
 * Copyright (c) 2017 Olivier Cammaert
 * Copyright (c) 2017 Maxim Deweirdt
 * Copyright (c) 2017 Gerwin Dox
 * Copyright (c) 2017 Simon Neuville
 * Copyright (c) 2017 Stiaan Uyttersprot
 *
 * This software may be modified and distributed under the terms of the MIT license.  See the LICENSE file for details.
 */

package com.dp16.runamicghent.DataProviderTests;

import android.location.Location;

import com.dp16.runamicghent.Constants;
import com.dp16.runamicghent.DataProvider.DistanceProvider;
import com.dp16.runamicghent.RunData.RunDistance;
import com.dp16.runamicghent.util.GpxReader;
import com.dp16.runamicghent.util.ThreadingUtils;
import com.dp16.eventbroker.EventBroker;
import com.dp16.eventbroker.EventListener;
import com.dp16.eventbroker.EventPublisherClass;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.annotation.Config;

import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

import static org.junit.Assert.assertEquals;

/**
 * Tests for DataProvider.DistanceProvider
 * Created by Nick on 19-3-2017.
 */

@RunWith(RobolectricTestRunner.class)
@Config(manifest = Config.NONE)
public class DistanceProviderTests {
    private EventBroker broker;
    private DistanceProvider underTest;
    private static final long waitingTime = 100; // ms
    private static final String gpxFilename = "plateau_zwijnaarde.gpx";
    private static final double accuracyRequired = 0.1; // as a fraction (0.01 = 1%)
    private static final int interval = 0; // interval to override the default 1 second in DistanceProvider

    /**
     * Util method to make a location from a lat, long coordinate
     *
     * @param latitude  in degrees (positive is E, negative is W)
     * @param longitude in degrees ( positive is N, negative is S)
     * @return a Location objects a generated by the android framework with the time set to now and the accuracy to perfect.
     */
    private Location makeLocation(double latitude, double longitude) {
        Location location = new Location("Mock provider");
        location.setLatitude(latitude);
        location.setLongitude(longitude);
        location.setTime(System.currentTimeMillis());
        location.setAccuracy(0);
        return location;
    }

    @Before
    public void init(){
        broker =  EventBroker.getInstance();
        underTest = new DistanceProvider();
        underTest.setInterval(interval);
    }

    @Test
    public void distanceProvider_dropsMeasurementsSmallerThanMinimumDistance() {
        final AtomicInteger received = new AtomicInteger(0);

        EventListener listener = new EventListener() {
            @Override
            public void handleEvent(String eventType, Object message) {
                received.incrementAndGet();
            }
        };

        broker.addEventListener(Constants.EventTypes.DISTANCE, listener);
        underTest.start();
        broker.start();

        EventPublisherClass publisherClass = new EventPublisherClass();
        Location location = makeLocation(51, 3);
        publisherClass.publishEvent(Constants.EventTypes.RAW_LOCATION, location);
        publisherClass.publishEvent(Constants.EventTypes.RAW_LOCATION, location);

        //wait for publisher to publish... (thread of publisher is slower than this main thread)
        try {
            Thread.sleep(waitingTime);
        } catch (InterruptedException e) {
            // no actions needed
        }

        broker.stop();
        underTest.stop();

        assertEquals("Did receive a distance for 2 measurements of the same point", 0, received.get());
    }

    @Test
    public void distanceProvider_acceptsMeasurementsJustAboveMinimumdistance() {
        // take start point, take point bit further away (add fixed number to one coord), test if location far enough
        final AtomicInteger received = new AtomicInteger(0);

        EventListener listener = new EventListener() {
            @Override
            public void handleEvent(String eventType, Object message) {
                received.incrementAndGet();
            }
        };

        broker.addEventListener(Constants.EventTypes.DISTANCE, listener);
        underTest.start();
        broker.start();

        EventPublisherClass publisherClass = new EventPublisherClass();
        Location startPoint = makeLocation(3, 51);
        publisherClass.publishEvent(Constants.EventTypes.RAW_LOCATION, startPoint);

        Location justFarEnough = makeLocation(3, 51);

        // move justFarEnough bit by bit until it is just far enough
        while (justFarEnough.distanceTo(startPoint) <= underTest.getMinimumDistance()) {
            justFarEnough.setLongitude(justFarEnough.getLongitude() + 0.00001);
        }
        publisherClass.publishEvent(Constants.EventTypes.RAW_LOCATION, justFarEnough);

        ThreadingUtils.waitOneSecUntilAtomicVariableReachesValue("Did not receive distance for 2 measurements just above minimum distance apart within ", received, 1);

        broker.stop();
        underTest.stop();
    }

    /* Changed the distance provider, but might change it back so don't remove this test.
    * Replaced by the test below.
    @Test
    public void distanceProvider_dropsMeasurementsOfBadAccuracy() {
        final AtomicInteger received = new AtomicInteger(0);

        EventListener listener = new EventListener() {
            @Override
            public void handleEvent(String eventType, Object message) {
                received.incrementAndGet();
            }
        };

        broker.addEventListener(Constants.EventTypes.DISTANCE, listener);
        underTest.start();
        broker.start();

        EventPublisherClass publisherClass = new EventPublisherClass();
        Location startPoint = makeLocation(3, 51);
        publisherClass.publishEvent(Constants.EventTypes.RAW_LOCATION, startPoint);

        Location badAccuracy = makeLocation(0, 0);
        badAccuracy.setAccuracy((float) underTest.getMinimumAccuracy() + 1);
        publisherClass.publishEvent(Constants.EventTypes.RAW_LOCATION, badAccuracy);

        try {
            Thread.sleep(waitingTime);
        } catch (InterruptedException e) {
            // no actions needed
        }

        broker.stop();
        underTest.stop();

        assertEquals("Did receive a distance for a bad accuracy location", 0, received.get());
    }
    */

    @Test
    public void distanceProvider_dropsMeasurementsOfBadAccuracy() {
        final AtomicInteger received = new AtomicInteger(0);

        EventListener listener = new EventListener() {
            @Override
            public void handleEvent(String eventType, Object message) {
                received.incrementAndGet();
            }
        };

        broker.addEventListener(Constants.EventTypes.DISTANCE, listener);
        underTest.start();
        broker.start();

        EventPublisherClass publisherClass = new EventPublisherClass();
        Location startPoint = makeLocation(3, 51);
        publisherClass.publishEvent(Constants.EventTypes.RAW_LOCATION, startPoint);

        Location badAccuracy = makeLocation(0, 0);
        badAccuracy.setAccuracy((float) (underTest.getRelativeAccuracy() * 1.1) * startPoint.distanceTo(badAccuracy));
        publisherClass.publishEvent(Constants.EventTypes.RAW_LOCATION, badAccuracy);

        try {
            Thread.sleep(waitingTime);
        } catch (InterruptedException e) {
            // no actions needed
        }

        broker.stop();
        underTest.stop();

        assertEquals("Did receive a distance for a bad accuracy location", 0, received.get());
    }

    @Test
    public void distanceProvider_givesAccurateMeasurementForPredefinedRoute() {
        // a very simple route with 6 points
        double accuracyDesired = 5; // in meters
        final AtomicInteger distanceReceived = new AtomicInteger(0);
        final AtomicInteger messagesReceived = new AtomicInteger(0);

        EventListener listener = new EventListener() {
            @Override
            public void handleEvent(String eventType, Object message) {
                RunDistance distance = (RunDistance) message;
                distanceReceived.set(distance.getDistance());
                messagesReceived.incrementAndGet();
            }
        };

        broker.addEventListener(Constants.EventTypes.DISTANCE, listener);
        underTest.start();
        broker.start();

        EventPublisherClass publisherClass = new EventPublisherClass();
        Location startPoint = makeLocation(3, 51);
        publisherClass.publishEvent(Constants.EventTypes.RAW_LOCATION, startPoint);

        Location secondLocation = makeLocation(3.2, 51);
        publisherClass.publishEvent(Constants.EventTypes.RAW_LOCATION, secondLocation);

        Location thirdLocation = makeLocation(3, 51.1);
        publisherClass.publishEvent(Constants.EventTypes.RAW_LOCATION, thirdLocation);

        Location fourthLocation = makeLocation(2.8, 51.15);
        publisherClass.publishEvent(Constants.EventTypes.RAW_LOCATION, fourthLocation);

        Location fifthLocation = makeLocation(2.7, 51.15);
        publisherClass.publishEvent(Constants.EventTypes.RAW_LOCATION, fifthLocation);

        Location sixthLocation = makeLocation(2.68, 51);
        publisherClass.publishEvent(Constants.EventTypes.RAW_LOCATION, sixthLocation);

        double realDistance = startPoint.distanceTo(secondLocation) + secondLocation.distanceTo(thirdLocation)
                + thirdLocation.distanceTo(fourthLocation) + fourthLocation.distanceTo(fifthLocation)
                + fifthLocation.distanceTo(sixthLocation);

        ThreadingUtils.waitOneSecUntilAtomicVariableReachesValue("Did not receive all 5 distance messages within ", messagesReceived, 5);

        broker.stop();
        underTest.stop();

        assertEquals("Distance reported by distance provider is not close to real distance", realDistance, distanceReceived.get(), accuracyDesired);
    }

    @Test
    public void distanceProvider_doesNotAcceptLocationUpdatesWhenPaused() {
        final AtomicInteger received = new AtomicInteger(0);

        EventListener listener = new EventListener() {
            @Override
            public void handleEvent(String eventType, Object message) {
                received.incrementAndGet();
            }
        };

        broker.addEventListener(Constants.EventTypes.DISTANCE, listener);
        underTest.start();
        broker.start();

        EventPublisherClass publisherClass = new EventPublisherClass();
        Location startPoint = makeLocation(3, 51);
        publisherClass.publishEvent(Constants.EventTypes.RAW_LOCATION, startPoint);

        underTest.pause();

        Location secondLocation = makeLocation(0, 0);
        publisherClass.publishEvent(Constants.EventTypes.RAW_LOCATION, secondLocation);

        try {
            Thread.sleep(waitingTime);
        } catch (InterruptedException e) {
            // no actions needed
        }

        underTest.resume();

        broker.stop();
        underTest.stop();

        assertEquals("Did receive a distance when distance provider should be paused", 0, received.get());
    }

    @Test
    public void distanceProvider_isWithinFewPercentOfRealRoute() {
        GpxReader reader = new GpxReader(gpxFilename);
        List<Location> locations = reader.getLocations();

        final AtomicInteger distanceReceived = new AtomicInteger(0);
        final AtomicInteger messageReceived = new AtomicInteger(0);

        EventListener listener = new EventListener() {
            @Override
            public void handleEvent(String eventType, Object message) {
                RunDistance distance = (RunDistance) message;
                distanceReceived.set(distance.getDistance());
                messageReceived.incrementAndGet();
            }
        };

        broker.addEventListener(Constants.EventTypes.DISTANCE, listener);
        underTest.start();
        broker.start();

        EventPublisherClass publisherClass = new EventPublisherClass();

        for (int i = 0; i < locations.size(); i++) {
            publisherClass.publishEvent(Constants.EventTypes.RAW_LOCATION, locations.get(i));
        }

        try {
            Thread.sleep(waitingTime);
        } catch (InterruptedException e) {
            // no actions needed
        }

        broker.stop();
        underTest.stop();

        double realDistance = reader.getTrackLength();
        assertEquals("DistanceProvider is not within " + accuracyRequired + " of the expected distance", realDistance, distanceReceived.get(), realDistance * accuracyRequired);
    }

}
